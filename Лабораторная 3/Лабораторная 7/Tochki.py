#!/usr/bin/env python3
# -*- кодирование: utf-8 -*-
'''
Провести рефакторниг кода, переписать программу в ООП стиле с использованием классов и наследования.
Реализовать класс 2-мерных векторов Vec2d.
В классе следует определить методы для основных математических операций, необходимых для работы с вектором.
Добавить возможность вычислять длину вектора с использованием функции len(a) и метод int_pair,
который возвращает кортеж из двух целых чисел (текущие координаты вектора).
Реализовать класс замкнутых ломаных Polyline с методами отвечающими за добавление в ломаную точки (Vec2d) c её скоростью,
пересчёт координат точек (set_points) и отрисовку ломаной (draw_points).
Арифметические действия с векторами должны быть реализованы с помощью операторов, а не через вызовы соответствующих методов.
Реализовать класс Knot (наследник класса Polyline), в котором добавление и пересчёт координат
инициируют вызов функции get_knot для расчёта точек кривой по добавляемым «опорным» точкам.????
Все классы должны быть самостоятельными и не использовать внешние функции.
'''

импорт pygame
импорт случайный
импорт математики

SCREEN_DIM = (800, 600)


# =======================================================================================
# класс 2-мерных векторов
# =======================================================================================
класс Vec2d:
    def __init__(self, args):
        себя. x = args[0]
        себя. y = args[ 1 ]


    def __sub__(само, другое):
        """"возвращает вектор разности двух векторов"""
        вернуть Vec2d([self. x - другое. x, само . y - другое. y])


    def __add__(само, другое):
        """возвращает вектор суммы двух векторов"""
        вернуть Vec2d([self. x + другое. x, само . y + другое. y])


    def __len__(само:
        """возвращает длину вектора"""
        вернуть математику. sqrt(само . x * само . x + само . y * само . y)


    def __mul__(само, k):
        """возвращает вектор произведения вектора на число"""
        вернуть Vec2d([self. x * k, само. y * k])


    def vec(x, y):
        """возвращает пару координат, определяющих вектор (координаты точки конца вектора),
        координаты начальной точки вектора совпадают с началом системы координат (0, 0)"""
        возврат y + x

    def int_pair(vec):
        возврат (vec. x, vec. y)

# =======================================================================================
# класс замкнутых ломаных
# =======================================================================================
класс Полилин:
    def add_point(очки, скорости, x, скорость):
        баллов. добавить(Vec2d(x))
        скоростей. добавить(Vec2d(скорость))

    def draw_points(точки, стиль="точки", ширина=3, цвет=(255, 255, 255)):
        """функция отрисовки точек на экране"""
        если стиль == "линия":
            для p_n в диапазоне(-1, лен (точек) - 1):
                пигейм. рисуй. линия(играДисплей, цвет,
                                (int(точки[p_n]. x), int(точек[p_n]. y)),
                                (int(точек[p_n + 1]. x), int(точек[p_n + 1]. y)), ширина)

        стиль elif == "очки":
            для p в баллах:
                пигейм. рисуй. круг(играДисплей, цвет,
                                  Vec2d. int_pair(p), ширина)
    def set_points(очки, скорости):
        """функция перерасчета координат опорных точек"""
        для p в диапазоне(len(точки)):
            точки[p] = точки[p] + скорости[p]
            если баллы[p]. x> SCREEN_DIM[0] или точки[p]. x < 0:
                скорости[p] = Vec2d([- скорости[p]. x, скорости[p]. y])
            если баллы[p]. y > SCREEN_DIM[1] или точки[p]. y < 0:
                скорости[p] = Vec2d([скорости[p]. x, -скорости[p]. y])



def draw_help():
    """функция отрисовки экрана справки программы"""
    играДисплей. заполнение((50, 50, 50))
    font1 = pygame. шрифт. SysFont("курьер", 24)
    font2 = pygame. шрифт. SysFont("засечка", 24)
    данные = []
    данные. добавить(["F1", "Показать справку"])
    данные. добавить(["R", "Перезагрузка"])
    данные. добавить(["P", "Пауза/Воспроизведение"])
    данные. добавить(["Число+", "Больше баллов"])
    данные. добавить(["Число-", "Меньше баллов"])
    данные. добавить(["", ""])
    данные. добавить([str(шаги), "Текущие точки"])

    пигейм. рисуй. линии(gameDisplay, (255, 50, 50, 255), True, [
        (0, 0), (800, 0), (800, 600), (0, 600) ], 5)
    для i, текст в перечислении(данные):
        играДисплей. blit(шрифт1. передавать(
            текст[0], True, (128, 128, 255)), (100, 100 + 30 * i))
        играДисплей. blit(шрифт2. передавать(
            текст[1], Правда, (128, 128, 255)), (200, 100 + 30 * i))


# =======================================================================================
# Функции, отвечающие за расчет сглаживания ломаной
# добавление и пересчёт координат инициируют вызов функции get_knot для расчёта точек кривой по добавляемым «опорным» точкам.
# =======================================================================================
класс Узел (Полилайн):
    def get_knot(очки, количество):
        если лен(пункты) < 3:
            возвращать []
        рез = []
        для i в диапазоне(-2, len(точек) - 2):
            птн = []
            ptn. добавить((пункты[i] + точки[i + 1] )* 0,5)
            ptn. добавить(пункты[i + 1])
            ptn. добавить((пункты[i + 1] + точки[i + 2]) * 0,5)

            рез. расширение(Узел. get_points(ptn, количество))
        возврат res


    def set_points(очки, скорости):
        """функция перерасчета координат опорных точек"""
        для p в диапазоне(len(точки)):
            точки[p] = точки[p] + скорости[p]
            если баллы[p]. x > SCREEN_DIM[0] или точки[p]. x < 0:
                скорости[p] = Vec2d([- скорости[p]. x, скорости[p]. y])
            если баллы[p]. y > SCREEN_DIM[1] или точки[p]. y < 0:
                скорости[p] = Vec2d([скорости[p]. x, -скорости[p]. y])

    def get_points(base_points, количество):
        альфа = 1 / количество
        рез = []
        для i в диапазоне(количество):
            рез. добавить(Узел. get_point(base_points, i  * альфа))
        возврат res

    def get_point(точки, альфа, deg=Нет):
        если deg — Нет:
            deg = лен(очки) - 1
        если дэг == 0:
            точки возврата [0]
        точки возврата [дэг] * альфа + узел. get_point(точки, альфа, ог - 1) * (1 - альфа)














# =======================================================================================
# Основная программа
# =======================================================================================
если __name__ == "__main__":
    пигейм. init()
    gameDisplay = pygame. дисплей. set_mode(SCREEN_DIM)
    пигейм. дисплей. set_caption(«Мой ЭкранНый застав»)

    шагов = 35
    рабочий = True
    точки = []
    скорости = []
    show_help = Ложь
    пауза = True

    оттенок = 0
    цвет = пигейм. Цвет(0)

    во время работы:
        для события в pygame. событие. получить():
            если событие. тип == pygame. ВЫЙТИ:
                рабочий = False
            если событие. тип == pygame. KEYDOWN:
                если событие. ключ == pygame. K_ESCAPE:
                    рабочий = False
                если событие. ключ == pygame. K_r:
                    точки = []
                    скорости = []
                если событие. ключ == pygame. K_p:
                    пауза = не пауза
                если событие. ключ == pygame. K_EQUALS и пигейм. ключ. get_mods() & pygame. KMOD_SHIFT:
                    шагов += 1
                если событие. ключ == pygame. K_F1:
                    show_help = не show_help
                если событие. ключ == pygame. K_MINUS:
                    шаги -= 1, если шаги > 1 еще 0

            если событие. тип == pygame. МЫШЬЮВКНУТАЯ КНОПКА:
                Полилин . add_point(очки, скорости, событие. pos, [случайный. случайный() * 2, случайный. случайный() * 2] )


        играДисплей. заполнение((0, 0, 0))
        оттенок = (оттенок + 1) % 360
        цвет. hsla = (оттенок, 100, 50, 100)
        Полилин . draw_points(баллы)
        Полилин . draw_points(Узел. get_knot(точки, шаги), "линия", 3, цвет)
        если не приостановить:
            Узел. set_points(очки, скорости)
        если show_help:
            draw_help()

        пигейм. дисплей. наглый()

    пигейм. дисплей. покидать()
    пигейм. покидать()
    выход(0)